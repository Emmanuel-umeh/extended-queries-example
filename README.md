# Extended Queries Example

### Advanced Customization with Amplication-Generated Code

This repository serves as a guide on how to enhance the capabilities of codebase generated by Amplication. While Amplication provides robust scaffolding for various data structures, there are instances where specific use cases aren't readily addressed by the generated code. 

This guide showcases how users can seamlessly integrate custom code to handle scenarios like deep nested queriesâ€”using an example of traversing structures like Order > Customer > Payment, and further extend the default functionalities to meet their unique requirements.

This is the part of the `prisma.schema` file to show the relevant part of this guide

```prisma
model Order {
  id         String    @id @default(cuid())
  customer   Customer? @relation(fields: [customerId], references: [id])
  customerId String?
}

model Customer {
  id        String    @id @default(cuid())
  orders    Order[]
  payments  Payment[]
}

model Payment {
  id          String                  @id @default(cuid())
  customer    Customer?               @relation(fields: [customerId], references: [id])
  customerId  String?
  paymentType EnumPaymentPaymentType?
}

enum EnumPaymentPaymentType {
  Card
  Cash
  Paypal
}
```

So, let's say that the requirement is to have an endpoint that returns all the orders that were made via "Paypal" as a payment method.

